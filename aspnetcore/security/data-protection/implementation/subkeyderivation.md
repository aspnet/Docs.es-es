---
title: Derivación de subclaves y cifrado autenticado en ASP.NET Core
author: rick-anderson
description: Obtenga información sobre la implementación de ASP.NET Core la derivación de subclaves de protección de datos y el cifrado autenticado.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ':::no-loc(appsettings.json):::'
- ':::no-loc(ASP.NET Core Identity):::'
- ':::no-loc(cookie):::'
- ':::no-loc(Cookie):::'
- ':::no-loc(Blazor):::'
- ':::no-loc(Blazor Server):::'
- ':::no-loc(Blazor WebAssembly):::'
- ':::no-loc(Identity):::'
- ":::no-loc(Let's Encrypt):::"
- ':::no-loc(Razor):::'
- ':::no-loc(SignalR):::'
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: efe8ad2f71feda9cbc1693d362e30eff29cbcd74
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060162"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="624f4-103">Derivación de subclaves y cifrado autenticado en ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="624f4-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="624f4-104">La mayoría de las claves del anillo clave contendrán alguna forma de entropía y tendrán información algorítmica que indica "cifrado de modo CBC + validación HMAC" o "cifrado y validación de GCM".</span><span class="sxs-lookup"><span data-stu-id="624f4-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="624f4-105">En estos casos, hacemos referencia a la entropía incrustada como el material de creación de claves maestro (o KM) para esta clave y realizamos una función de derivación de claves para derivar las claves que se usarán para las operaciones criptográficas reales.</span><span class="sxs-lookup"><span data-stu-id="624f4-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="624f4-106">Las claves son abstractas y es posible que una implementación personalizada no se comporte como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="624f4-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="624f4-107">Si la clave proporciona su propia implementación de `IAuthenticatedEncryptor` en lugar de usar uno de nuestros generadores integrados, ya no se aplica el mecanismo descrito en esta sección.</span><span class="sxs-lookup"><span data-stu-id="624f4-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="624f4-108">Derivación de subclaves y datos autenticados adicionales</span><span class="sxs-lookup"><span data-stu-id="624f4-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="624f4-109">La `IAuthenticatedEncryptor` interfaz actúa como la interfaz principal para todas las operaciones de cifrado autenticadas.</span><span class="sxs-lookup"><span data-stu-id="624f4-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="624f4-110">Su `Encrypt` método toma dos búferes: Plaintext y additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="624f4-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="624f4-111">El contenido de texto no cifrado fluye sin modificar la llamada a `IDataProtector.Protect` , pero el sistema genera AAD y consta de tres componentes:</span><span class="sxs-lookup"><span data-stu-id="624f4-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="624f4-112">El encabezado mágico de 32 bits 09 F0 C9 F0 que identifica esta versión del sistema de protección de datos.</span><span class="sxs-lookup"><span data-stu-id="624f4-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="624f4-113">Identificador de clave de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="624f4-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="624f4-114">Cadena de longitud variable formada a partir de la cadena propósito que creó el objeto `IDataProtector` que está realizando esta operación.</span><span class="sxs-lookup"><span data-stu-id="624f4-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="624f4-115">Dado que AAD es único para la tupla de los tres componentes, podemos usarlo para derivar nuevas claves de KM en lugar de usar KM en todas nuestras operaciones criptográficas.</span><span class="sxs-lookup"><span data-stu-id="624f4-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="624f4-116">Para cada llamada a `IAuthenticatedEncryptor.Encrypt` , se produce el siguiente proceso de derivación de claves:</span><span class="sxs-lookup"><span data-stu-id="624f4-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="624f4-117">Aquí, llamamos a NIST SP800-108 KDF en el modo de contador (consulte [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) con los siguientes parámetros:</span><span class="sxs-lookup"><span data-stu-id="624f4-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="624f4-118">Clave de derivación de claves (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="624f4-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="624f4-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="624f4-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="624f4-120">etiqueta = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="624f4-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="624f4-121">contexto = contextHeader | | keyModifier</span><span class="sxs-lookup"><span data-stu-id="624f4-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="624f4-122">El encabezado de contexto es de longitud variable y básicamente sirve como huella digital de los algoritmos para los que se van a derivar `K_E` y `K_H` .</span><span class="sxs-lookup"><span data-stu-id="624f4-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="624f4-123">El modificador de clave es una cadena de 128 bits generada aleatoriamente para cada llamada a `Encrypt` y sirve para garantizar una probabilidad abrumadora de que ke y KH sean únicos para esta operación de cifrado de autenticación específica, aunque todas las demás entradas de KdF sean constantes.</span><span class="sxs-lookup"><span data-stu-id="624f4-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="624f4-124">En el caso del cifrado de modo CBC y las operaciones de validación HMAC, `| K_E |` es la longitud de la clave de cifrado de bloques simétricos y `| K_H |` es el tamaño de síntesis de la rutina HMAC.</span><span class="sxs-lookup"><span data-stu-id="624f4-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="624f4-125">Para el cifrado y las operaciones de validación de GCM, `| K_H | = 0` .</span><span class="sxs-lookup"><span data-stu-id="624f4-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="624f4-126">Cifrado de modo CBC + validación HMAC</span><span class="sxs-lookup"><span data-stu-id="624f4-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="624f4-127">Una vez que `K_E` se genera mediante el mecanismo anterior, se genera un vector de inicialización aleatorio y se ejecuta el algoritmo de cifrado de bloque simétrico para cifrar el texto no cifrado.</span><span class="sxs-lookup"><span data-stu-id="624f4-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="624f4-128">El vector de inicialización y el texto cifrado se ejecutan a través de la rutina HMAC inicializada con la clave `K_H` para producir el equipo Mac.</span><span class="sxs-lookup"><span data-stu-id="624f4-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="624f4-129">Este proceso y el valor devuelto se representan gráficamente a continuación.</span><span class="sxs-lookup"><span data-stu-id="624f4-129">This process and the return value is represented graphically below.</span></span>

![Proceso y devolución de modo CBC](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="624f4-131">La `IDataProtector.Protect` implementación [anteponerá el encabezado mágico y el ID](xref:security/data-protection/implementation/authenticated-encryption-details) . de clave a la salida antes de devolverlos al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="624f4-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="624f4-132">Dado que el encabezado mágico y el ID. de clave forman parte implícitamente de [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), y dado que el modificador de clave se introduce como entrada para KDF, esto significa que el equipo Mac autentica cada uno de los bytes de la carga devuelta final.</span><span class="sxs-lookup"><span data-stu-id="624f4-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="624f4-133">Cifrado de modo de Galois/contador + validación</span><span class="sxs-lookup"><span data-stu-id="624f4-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="624f4-134">Una vez que `K_E` se genera mediante el mecanismo anterior, se genera un nonce aleatorio de 96 bits y se ejecuta el algoritmo de cifrado de bloques simétricos para cifrar el texto sin formato y generar la etiqueta de autenticación de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="624f4-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Proceso y devolución de modo GCM](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="624f4-136">Aunque GCM es compatible de forma nativa con el concepto de AAD, todavía estamos alimentando AAD solo para el KDF original, y optando por pasar una cadena vacía a GCM para su parámetro de AAD.</span><span class="sxs-lookup"><span data-stu-id="624f4-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="624f4-137">El motivo de esto es el doble.</span><span class="sxs-lookup"><span data-stu-id="624f4-137">The reason for this is two-fold.</span></span> <span data-ttu-id="624f4-138">En primer lugar, [para admitir la agilidad](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) , nunca queremos usar `K_M` directamente como clave de cifrado.</span><span class="sxs-lookup"><span data-stu-id="624f4-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="624f4-139">Además, GCM impone requisitos de unicidad muy estrictos en sus entradas.</span><span class="sxs-lookup"><span data-stu-id="624f4-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="624f4-140">La probabilidad de que la rutina de cifrado de GCM se invoque en dos o más conjuntos distintos de datos de entrada con el mismo par (clave, nonce) no debe superar los 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="624f4-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="624f4-141">Si se corrige `K_E` , no se pueden realizar más de 2 ^ 32 operaciones de cifrado antes de que se ejecute afoul del límite de 2 ^-32.</span><span class="sxs-lookup"><span data-stu-id="624f4-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="624f4-142">Esto podría parecer un gran número de operaciones, pero un servidor Web de tráfico alto puede pasar por 4 mil millones solicitudes en cuestión de días, dentro de la duración normal de estas claves.</span><span class="sxs-lookup"><span data-stu-id="624f4-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="624f4-143">Para mantener la compatibilidad con el límite de probabilidad de 2 ^-32, se sigue usando un modificador de clave de 128 bits y un nonce de 96 bits, que amplía radicalmente el recuento de operaciones utilizable para cualquier `K_M` .</span><span class="sxs-lookup"><span data-stu-id="624f4-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="624f4-144">Para simplificar el diseño, se comparte la ruta de acceso del código de KDF entre las operaciones CBC y GCM, y dado que AAD ya se tiene en cuenta en el KDF, no es necesario reenviarlo a la rutina GCM.</span><span class="sxs-lookup"><span data-stu-id="624f4-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
