---
title: Migrar de ASP.NET Core 2,2 a 3,0
author: rick-anderson
description: Obtenga información sobre cómo migrar un proyecto ASP.NET Core 2,2 a ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 2f8602dd1356fdc5a224545805da9532426c6dec
ms.sourcegitcommit: 8b0e9a72c1599ce21830c843558a661ba908ce32
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/08/2021
ms.locfileid: "98024813"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar de ASP.NET Core 2,2 a 3,0

Por [Scott Addie](https://github.com/scottaddie) y [Rick Anderson](https://twitter.com/RickAndMSFT)

En este artículo se explica cómo actualizar un proyecto ASP.NET Core 2,2 existente a ASP.NET Core 3,0. Puede ser útil crear un nuevo proyecto ASP.NET Core 3,0 para:

* Compare con el código ASP.NET Core 2,2.
* Copie los cambios pertinentes en el proyecto ASP.NET Core 3,0.

## <a name="prerequisites"></a>Requisitos previos

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Actualización de la versión del SDK de .NET Core en global.json

Si la solución se basa en una [global.jsen](/dotnet/core/tools/global-json) archivo para tener como destino una versión de SDK de .net Core específica, actualice su `version` propiedad a la versión 3,0 instalada en el equipo:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Actualizar el archivo de proyecto

### <a name="update-the-target-framework"></a>Actualización de la plataforma de destino

ASP.NET Core 3,0 y versiones posteriores solo se ejecutan en .NET Core. Establezca el [moniker de la plataforma de destino (TFM)](/dotnet/standard/frameworks) en `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Quitar referencias de paquetes obsoletas

No se produce un gran número de paquetes NuGet para ASP.NET Core 3,0. Estas referencias de paquete deben quitarse del archivo de proyecto. Considere el siguiente archivo de proyecto para una aplicación Web ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

El archivo de proyecto actualizado para ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

El archivo de proyecto actualizado ASP.NET Core 3,0:

* En `<PropertyGroup>`:
  * Actualiza el TFM a `netcoreapp3.0`
  * Quita el `<AspNetCoreHostingModel>` elemento. Para obtener más información, vea [modelo de hospedaje en proceso](#in-process-hosting-model) en este documento.

* En `<ItemGroup>`:
  * `Microsoft.AspNetCore.App` se ha quitado. Para obtener más información, vea [referencia de Framework](#framework-reference) en este documento.
  * `Microsoft.AspNetCore.Razor.Design` se quita y en la siguiente lista de paquetes ya no se generan.

Para ver la lista completa de los paquetes que ya no se generan, seleccione la siguiente lista de Expand:

<details>
    <summary>Haga clic para expandir la lista de paquetes que ya no se generan</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. AspNetCore. Authentication. Cookie seg</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. AspNetCore. Cookie Directivas</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft. AspNetCore. Mvc. Razor . ViewCompilation</li>
        <li>Microsoft. AspNetCore. Mvc. Razor Páginas</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Runtime</li>
        <li>Microsoft. AspNetCore. Razor . Concepción</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revisar cambios importantes

[Revisar cambios importantes](#break)

### <a name="framework-reference"></a>Referencia de Framework

Las características de ASP.NET Core que estaban disponibles a través de uno de los paquetes enumerados anteriormente están disponibles como parte del `Microsoft.AspNetCore.App` marco de trabajo compartido. El *marco compartido* es el conjunto de ensamblados (archivos *.dll*) que se instalan en la máquina e incluye un componente de entorno de ejecución y un paquete de destino. Para más información, consulte este artículo sobre el [marco de trabajo compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Los proyectos que tienen como destino el SDK de `Microsoft.NET.Sdk.Web` hacen referencia implícitamente al marco `Microsoft.AspNetCore.App`.

  No se requieren referencias adicionales para estos proyectos:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Los proyectos que `Microsoft.NET.Sdk` tienen como destino o `Microsoft.NET.Sdk.Razor` SDK deben agregar explícitamente `FrameworkReference` a `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilaciones dependientes de Framework mediante Docker

Las compilaciones dependientes del marco de trabajo de aplicaciones de consola que usan un paquete que depende de la ASP.NET Core [marco compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) pueden dar el siguiente error de tiempo de ejecución:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` es el marco de trabajo compartido que contiene el tiempo de ejecución de ASP.NET Core y solo está presente en la imagen de Docker [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . El SDK de 3,0 reduce el tamaño de las compilaciones dependientes del marco de trabajo mediante ASP.NET Core sin incluir copias duplicadas de las bibliotecas que están disponibles en el marco de trabajo compartido. Se trata de un ahorro potencial de hasta 18 MB, pero requiere que el tiempo de ejecución de ASP.NET Core esté presente o instalado para ejecutar la aplicación.

Para determinar si la aplicación tiene una dependencia (directa o indirecta) en el ASP.NET Core marco compartido, examine el *runtimeconfig.jsen* el archivo generado durante una compilación o publicación de la aplicación. El siguiente archivo JSON muestra una dependencia en el ASP.NET Core marco compartido:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si la aplicación usa Docker, use una imagen base que incluya ASP.NET Core 3,0. Por ejemplo: `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Agregar referencias de paquete para los ensamblados quitados

ASP.NET Core 3,0 quita algunos ensamblados que anteriormente formaban parte de la `Microsoft.AspNetCore.App` referencia de paquete. Para visualizar qué ensamblados se quitaron, compare las dos carpetas compartidas de .NET Framework. Por ejemplo, una comparación de las versiones 2.2.7 y 3.0.0:

![comparación de ensamblados de Marcos compartidos](22-to-30/_static/assembly-diff.png)

Para seguir usando las características proporcionadas por los ensamblados quitados, haga referencia a las versiones 3,0 de los paquetes correspondientes:

* Una aplicación web generada por una plantilla con **cuentas de usuario individuales** requiere la adición de los siguientes paquetes:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obtener más información sobre cómo hacer referencia al paquete específico del proveedor de bases de datos, vea [proveedores de bases de datos](/ef/core/providers/index).

* IU de Identity

  La compatibilidad con la [ Identity interfaz de usuario](xref:security/authentication/identity) se puede Agregar haciendo referencia a [Microsoft. AspNetCore. Identity . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI)Paquete de interfaz de usuario.

* Servicios de SPA

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Autenticación: la compatibilidad con flujos de autenticación de terceros está disponible como paquetes NuGet:

  * OAuth de Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticación de la cuenta Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticación de OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token de portador de OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticación WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Compatibilidad con el formato y la negociación de contenido para `System.Net.HttpClient` : el paquete NuGet [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) proporciona una extensibilidad útil para `System.Net.HttpClient` con las API como `ReadAsAsync` y `PostJsonAsync` .

* Razor compilación en tiempo de ejecución: la compatibilidad con la compilación en tiempo de ejecución de Razor vistas y páginas ahora forma parte de [Microsoft. AspNetCore. Mvc. Razor . RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Compatibilidad con MVC `Newtonsoft.Json` (JSON.net): la compatibilidad con el uso de MVC con `Newtonsoft.Json` ahora forma parte de [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Cambios de inicio

En la imagen siguiente se muestran las líneas eliminadas y modificadas en una aplicación Web de ASP.NET Core 2,2 Razor páginas:

![las líneas eliminadas y modificadas en un ASP.NET Core 2,2::: no-LOC (Razor)::: aplicación Web](22-to-30/_static/startup2.2.png)

En la imagen anterior, el código eliminado se muestra en rojo. El código eliminado no muestra el cookie código de las opciones, que se eliminó antes de comparar los archivos.

En la imagen siguiente se muestran las líneas agregadas y modificadas en una aplicación Web de ASP.NET Core 3,0 Razor páginas:

![las líneas agregadas y modificadas en un ASP.NET Core 3,0::: no-LOC (Razor)::: aplicación Web](22-to-30/_static/startup3.0.png)

En la imagen anterior, el código agregado se muestra en verde. Para obtener información sobre los cambios siguientes:

* `services.AddMvc` para `services.AddRazorPages` , consulte [registro del servicio MVC](#mvc-service-registration) en este documento.
* `CompatibilityVersion`, vea <xref:mvc/compatibility-version> .
* `IHostingEnvironment` para `IWebHostEnvironment` , consulte [este anuncio de github](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` se agregó a las plantillas para mostrar que se debe agregar el middleware de autorización de pedido. Si la aplicación no usa la autorización, puede quitar de forma segura la llamada a `app.UseAuthorization` .
* `app.UseEndpoints`, vea [ Razor páginas](#razor-pages) o [migrar Startup.Config](#migrate-startupconfigure) en este documento.

### <a name="analyzer-support"></a>Compatibilidad con analizador

Los proyectos que tienen `Microsoft.NET.Sdk.Web` como destino los analizadores de referencia implícita anteriormente se incluyen como parte del paquete [Microsoft. AspNetCore. Mvc. analizadores](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . No se requieren referencias adicionales para habilitarlas.

Si su aplicación usa [analizadores de API](xref:web-api/advanced/analyzers) previamente enviados mediante el paquete [Microsoft. AspNetCore. Mvc. API. analizadores](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edite el archivo de proyecto para que haga referencia a los analizadores que se incluyen como parte del SDK Web de .net Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="no-locrazor-class-library"></a>Razor Biblioteca de clases

Razor Los proyectos de biblioteca de clases que proporcionan los componentes de interfaz de usuario para MVC deben establecer la `AddRazorSupportForMvc` propiedad en el archivo de proyecto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedaje en proceso

Los proyectos tienen como valor predeterminado el [modelo de hospedaje en proceso](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) en ASP.net Core 3,0 o posterior. Opcionalmente, puede quitar la `<AspNetCoreHostingModel>` propiedad en el archivo de proyecto si su valor es `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuración

Migrar la configuración de Kestrel al [generador de hosts web](#hostb) proporcionado por `ConfigureWebHostDefaults` (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si la aplicación crea el host manualmente con `ConfigureWebHost` en lugar de `ConfigureWebHostDefaults` , llame a `UseKestrel` en el generador de hosts Web:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>El middleware de conexión reemplaza los adaptadores de conexión

Los adaptadores de conexión ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) se han quitado de Kestrel. Reemplace los adaptadores de conexión por el middleware de conexión. El middleware de conexión es similar al middleware HTTP en la canalización de ASP.NET Core, pero para las conexiones de nivel inferior. HTTPS y registro de conexiones:

* Se han pasado de los adaptadores de conexión al middleware de conexión.
* Estos métodos de extensión funcionan como en versiones anteriores de ASP.NET Core. 

Para obtener más información, consulte [el ejemplo de TlsFilterConnectionHandler en la sección ListenOptions. Protocols del artículo Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstracciones de transporte que se movieron y hicieron públicas

La capa de transporte de Kestrel se ha expuesto como una interfaz pública en `Connections.Abstractions`. Como parte de estas actualizaciones:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` y se han quitado los tipos asociados.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> se ha pasado de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> a las opciones de transporte.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` se ha quitado de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Para obtener más información, consulte los siguientes recursos de GitHub:

* [Abstracciones de red de cliente/servidor (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementar una nueva abstracción de escucha de cimientos y volver a Kestrel en la parte superior (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel encabezados de finalizador de solicitud

En el caso de las aplicaciones destinadas a versiones anteriores de ASP.NET Core:

* Kestrel agrega encabezados de finalizador fragmentados de HTTP/1.1 a la colección de encabezados de solicitud.
* Los finalizadores están disponibles después de leer el cuerpo de la solicitud hasta el final.

Esto provoca algunos problemas sobre la ambigüedad entre encabezados y finalizadores, por lo que los finalizadores se han desplazado a una nueva colección ( `RequestTrailerExtensions` ) en 3,0.

Los finalizadores de solicitudes HTTP/2 son:

* No disponible en ASP.NET Core 2,2.
* Disponible en 3,0 como `RequestTrailerExtensions` .

Hay nuevos métodos de extensión de solicitud para tener acceso a estos finalizadores. Al igual que con HTTP/1.1, los finalizadores están disponibles después de leer el cuerpo de la solicitud hasta el final.

Para la versión 3,0, `RequestTrailerExtensions` están disponibles los siguientes métodos:

* `GetDeclaredTrailers`: Obtiene el encabezado de solicitud `Trailer` que muestra los finalizadores que se esperan después del cuerpo.
* `SupportsTrailers`: Indica si la solicitud admite encabezados de finalizador de recepción.
* `CheckTrailersAvailable`: Comprueba si la solicitud admite finalizadores y si está disponible para su lectura. En esta comprobación no se da por hecho que hay finalizadores para leer. Es posible que no haya finalizaciones de lectura aunque `true` este método devuelva un resultado.
* `GetTrailer`: Obtiene el encabezado final solicitado de la respuesta. Compruebe `SupportsTrailers` antes de llamar a `GetTrailer` , o <xref:System.NotSupportedException> puede producirse si la solicitud no admite encabezados finales.

Para obtener más información, consulte [colocar finalizadores de solicitudes en una colección independiente (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO deshabilitado

`AllowSynchronousIO` habilita o deshabilita las API de e/s sincrónicas, como `HttpRequest.Body.Read` , `HttpResponse.Body.Write` y `Stream.Flush` . Estas API son un origen de colapso de subprocesos que conduce a bloqueos de la aplicación. En la versión 3.0, `AllowSynchronousIO` se ha deshabilitado de manera predeterminada. Para obtener más información, consulte [la sección de e/s sincrónica en el artículo de Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#synchronous-io).

Si se necesita e/s sincrónica, se puede habilitar configurando la `AllowSynchronousIO` opción en el servidor que se está usando (cuando se llama a `ConfigureKestrel` , por ejemplo, si se usa Kestrel). Tenga en cuenta que los servidores (Kestrel, TestServer, etc.) tienen su propia `AllowSynchronousIO` opción que no afectará a otros servidores. La e/s sincrónica se puede habilitar para todos los servidores en cada solicitud mediante la `IHttpBodyControlFeature.AllowSynchronousIO` opción:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si tiene problemas con las <xref:System.IO.TextWriter> implementaciones u otras secuencias que llaman a las API sincrónicas en [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), llame a la nueva <xref:System.IO.Stream.DisposeAsync*> API en su lugar.

Para obtener más información, vea [[anuncio] AllowSynchronousIO deshabilitado en todos los servidores (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Almacenamiento en búfer del formateador de salida

[Newtonsoft.Jsen](https://www.newtonsoft.com/json), <xref:System.Xml.Serialization.XmlSerializer> y los <xref:System.Runtime.Serialization.DataContractSerializer> formateadores de salida basados solo admiten la serialización sincrónica. Para permitir que estos formateadores funcionen con las restricciones de [AllowSynchronousIO](https://github.com/dotnet/aspnetcore/issues/7644) del servidor, MVC almacena en búfer el resultado de estos formateadores antes de escribir en el disco. Como resultado del almacenamiento en búfer, MVC incluirá el encabezado Content-Length al responder con estos formateadores.

<xref:System.Text.Json> admite la serialización asincrónica y, por consiguiente, el `System.Text.Json` formateador basado en no almacena en búfer. Considere la posibilidad de usar este formateador para mejorar el rendimiento.

Para deshabilitar el almacenamiento en búfer, las aplicaciones pueden configurar <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> en su inicio:

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Tenga en cuenta que esto puede dar lugar a que la aplicación inicie una excepción en tiempo de ejecución si `AllowSynchronousIO` no se configura también.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Se quitó el ensamblado Microsoft. AspNetCore. Server. Kestrel. https

En ASP.NET Core 2,1, el contenido de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* se ha pasado a *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Se trata de una actualización no interrumpida mediante `TypeForwardedTo` atributos. En 3,0, se han quitado el ensamblado de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* vacío y el paquete NuGet.

Las bibliotecas que hacen referencia a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) deben actualizar las dependencias ASP.NET Core a 2,1 o posterior.

Las aplicaciones y bibliotecas que tienen como destino ASP.NET Core 2,1 o posterior deben quitar las referencias directas al paquete [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Compatibilidad con Newtonsoft.Json (Json.NET)

Como parte del trabajo de [mejorar el marco compartido de ASP.net Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Newtonsoft.Js(JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) se ha quitado de la ASP.net Core marco compartido.

El serializador JSON predeterminado para ASP.NET Core es ahora <xref:System.Text.Json> , que es nuevo en .net Core 3,0. Considere la posibilidad de usar `System.Text.Json` cuando sea posible. Es de alto rendimiento y no requiere una dependencia de biblioteca adicional. Sin embargo, como `System.Text.Json` es nuevo, es posible que actualmente falten características que la aplicación necesita. Para obtener más información, consulte [How to Migrate from Newtonsoft.Json to System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-no-locsignalr-project"></a>Usar Newtonsoft.Jsen un proyecto ASP.NET Core 3,0 SignalR

* Instale [Microsoft. AspNetCore. SignalR . Paquete NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .

* En el cliente, encadenar una `AddNewtonsoftJsonProtocol` llamada de método a la `HubConnectionBuilder` instancia:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* En el servidor, encadenar una `AddNewtonsoftJsonProtocol` llamada de método a la `AddSignalR` llamada al método en `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Usar Newtonsoft.Jsen un proyecto de MVC de ASP.NET Core 3,0

* Instale el [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) paquete.

* Actualización `Startup.ConfigureServices` que se va a llamar `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` es compatible con los nuevos métodos de registro del servicio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` la configuración se puede establecer en la llamada a `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

  **Nota:** Si el `AddNewtonsoftJson` método no está disponible, asegúrese de que ha instalado el [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) paquete. Un error común es instalar el [Newtonsoft.Jsen](https://www.nuget.org/packages/Newtonsoft.Json/) el paquete en lugar del [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) paquete.

Para obtener más información, consulte [incorporación de compatibilidad con el formato JSON basado en Newtonsoft.Js](xref:web-api/advanced/formatting#add-newtonsoftjson-based-json-format-support).

## <a name="mvc-service-registration"></a>Registro del servicio MVC

ASP.NET Core 3,0 agrega nuevas opciones para registrar escenarios MVC en `Startup.ConfigureServices` .

Hay disponibles tres nuevos métodos de extensión de nivel superior relacionados con los escenarios MVC en `IServiceCollection` . Las plantillas usan estos nuevos métodos en lugar de `AddMvc` . Sin embargo, `AddMvc` continúa comportándose como tiene en versiones anteriores.

En el ejemplo siguiente se agrega compatibilidad con controladores y características relacionadas con la API, pero no vistas o páginas. La plantilla de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

En el ejemplo siguiente se agrega compatibilidad con controladores, características relacionadas con la API y vistas, pero no páginas. La plantilla aplicación web (MVC) utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

En el ejemplo siguiente se agrega compatibilidad con Razor las páginas y la compatibilidad mínima con el controlador. La plantilla de aplicación Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

También se pueden combinar los nuevos métodos. El ejemplo siguiente es equivalente a llamar a `AddMvc` en ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicio de enrutamiento

Si una aplicación llama a `UseMvc` o `UseSignalR` , migre la aplicación al [enrutamiento del punto de conexión](xref:fundamentals/routing) , si es posible. Para mejorar la compatibilidad del enrutamiento de puntos de conexión con versiones anteriores de MVC, hemos revertido algunos de los cambios en la generación de direcciones URL introducidos en ASP.NET Core 2,2. Si experimenta problemas al usar el enrutamiento de puntos de conexión en 2,2, espere mejoras en ASP.NET Core 3,0 con las siguientes excepciones:

* Si la aplicación implementa `IRouter` o hereda de `Route` , use [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) como reemplazo.
* Si la aplicación accede directamente `RouteData.Routers` a MVC para analizar las direcciones URL, puede reemplazarlo por el uso de [LinkParser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Defina la ruta con un nombre de ruta.
  * Use `LinkParser.ParsePathByEndpointName` y pase el nombre de ruta deseado.

El enrutamiento de puntos de conexión admite la misma sintaxis de patrón de ruta y características de creación de patrones de ruta que `IRouter` . El enrutamiento del extremo admite `IRouteConstraint` . El enrutamiento del punto de conexión admite `[Route]` , `[HttpGet]` y los demás atributos de enrutamiento de MVC.

Para la mayoría de las aplicaciones, solo `Startup` requiere cambios.

### <a name="migrate-startupconfigure"></a>Migración de Startup.Config

Consejos generales:

* Agregue `UseRouting`.
* Si la aplicación llama a `UseStaticFiles` , coloque `UseStaticFiles` **antes** de `UseRouting` .
* Si la aplicación usa características de autenticación/autorización como `AuthorizePage` o `[Authorize]` , coloque la llamada a `UseAuthentication` y `UseAuthorization` : **después** de, `UseRouting` y `UseCors` , pero antes de `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Reemplace `UseMvc` o `UseSignalR` por `UseEndpoints` .
* Si la aplicación usa escenarios de [CORS](xref:security/cors) , como `[EnableCors]` , coloque la llamada a `UseCors` antes de cualquier otro middleware que use CORS (por ejemplo, coloque `UseCors` antes `UseAuthentication` , `UseAuthorization` y `UseEndpoints` ).
* Reemplace `IHostingEnvironment` por `IWebHostEnvironment` y agregue una `using` instrucción para el <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres.
* Reemplazar `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres).
* Reemplazar `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres).

El código siguiente es un ejemplo de `Startup.Configure` en una aplicación típica ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Después de actualizar el `Startup.Configure` código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para la mayoría de las aplicaciones, las llamadas a `UseAuthentication` , `UseAuthorization` y `UseCors` deben aparecer entre las llamadas a `UseRouting` y `UseEndpoints` para ser efectivas.

### <a name="health-checks"></a>Comprobaciones de estado

Las comprobaciones de estado utilizan el enrutamiento de puntos de conexión con el host genérico. En `Startup.Configure`, llame a `MapHealthChecks` en el generador de puntos de conexiones con la dirección URL del punto de conexión o la ruta de acceso relativa:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Los puntos de conexión de las comprobaciones de estado pueden:

* Especificar uno o más hosts o puertos permitidos.
* Requerir autorización.
* Requerir CORS.

Para obtener más información, vea <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guía de middleware de seguridad

La compatibilidad con la autorización y CORS está unificada en torno al enfoque de [middleware](xref:fundamentals/middleware/index) . Esto permite el uso del mismo middleware y la misma funcionalidad en estos escenarios. En esta versión se proporciona un middleware de autorización actualizado, y el middleware CORS se ha mejorado para que pueda comprender los atributos usados por los controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, CORS podía ser difícil de configurar. El middleware se proporcionó para su uso en algunos casos de uso, pero los filtros de MVC debían usarse **sin** el middleware en otros casos de uso. Con ASP.NET Core 3,0, se recomienda que todas las aplicaciones que requieren CORS usen el middleware de CORS en tándem con el enrutamiento de puntos de conexión. `UseCors` se puede proporcionar con una directiva predeterminada, y `[EnableCors]` `[DisableCors]` los atributos y se pueden usar para invalidar la directiva predeterminada cuando sea necesario.

En el ejemplo siguiente:

* CORS está habilitado para todos los puntos de conexión con la `default` Directiva con nombre.
* La `MyController` clase deshabilita CORS con el `[DisableCors]` atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorización

En versiones anteriores de ASP.NET Core, se proporcionaba compatibilidad con la autorización mediante el `[Authorize]` atributo. El middleware de autorización no estaba disponible. En ASP.NET Core 3,0, se requiere middleware de autorización. Se recomienda colocar el middleware de autorización de ASP.NET Core ( `UseAuthorization` ) inmediatamente después de `UseAuthentication` . El middleware de autorización también puede configurarse con una directiva predeterminada, que se puede invalidar.

En ASP.NET Core 3,0 o posterior, `UseAuthorization` se llama a en `Startup.Configure` , y lo siguiente `HomeController` requiere un usuario con sesión iniciada:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Al usar el enrutamiento de punto de conexión, se recomienda no configurar `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` y, en su lugar, confiar en el middleware de autorización.  Si la aplicación usa `AuthorizeFilter` como filtro global en MVC, se recomienda refactorizar el código para proporcionar una directiva en la llamada a `AddAuthorization` .

`DefaultPolicy`Se configura inicialmente para requerir autenticación, por lo que no se requiere ninguna configuración adicional. En el ejemplo siguiente, los puntos de conexión de MVC se marcan como `RequireAuthorization` para que todas las solicitudes se deben autorizar en función de `DefaultPolicy` . Sin embargo, `HomeController` permite el acceso sin que el usuario inicie sesión en la aplicación debido a `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorización para puntos de conexión específicos

La autorización también puede configurarse para clases específicas de puntos de conexión. El código siguiente es un ejemplo de conversión de una aplicación MVC que configuró un global `AuthorizeFilter` en una aplicación con una directiva específica que requiere autorización:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

También se pueden personalizar las directivas. `DefaultPolicy`Está configurado para requerir autenticación:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Como alternativa, se pueden configurar todos los puntos de conexión para requerir `[Authorize]` la autorización sin o `RequireAuthorization` mediante la configuración de `FallbackPolicy` . `FallbackPolicy`Es diferente de `DefaultPolicy` . `DefaultPolicy`Se desencadena con `[Authorize]` o `RequireAuthorization` , mientras que `FallbackPolicy` se desencadena cuando no se establece ninguna otra directiva. `FallbackPolicy` está configurado inicialmente para permitir solicitudes sin autorización.

El ejemplo siguiente es el mismo que el anterior, `DefaultPolicy` pero usa `FallbackPolicy` para requerir siempre la autenticación en todos los extremos excepto cuando `[AllowAnonymous]` se especifica:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

La autorización por middleware funciona sin el marco de trabajo que tiene un conocimiento específico de la autorización. Por ejemplo, las [comprobaciones de estado](xref:host-and-deploy/health-checks) no tienen ningún conocimiento específico de la autorización, pero las comprobaciones de estado pueden tener una directiva de autorización configurable aplicada por el middleware.

Además, cada punto de conexión puede personalizar sus requisitos de autorización. En el ejemplo siguiente, `UseAuthorization` procesa la autorización con `DefaultPolicy` , pero el `/healthz` extremo de comprobación de estado requiere un `admin` usuario:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protección se implementa en algunos escenarios. El middleware de extremos inicia una excepción si se omite una directiva de autorización o CORS debido a que falta un middleware. La compatibilidad con el analizador para proporcionar información adicional sobre la configuración inestable está en curso.

#### <a name="custom-authorization-handlers"></a>Controladores de autorización personalizados

Si la aplicación usa [controladores de autorización](xref:security/authorization/policies#authorization-handlers)personalizados, el enrutamiento del punto de conexión pasa un tipo de recurso diferente a los controladores que MVC. Los controladores que esperan que el recurso de contexto del controlador de autorización sea de tipo <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (el tipo de recurso [proporcionado por los filtros MVC](xref:security/authorization/policies#access-mvc-request-context-in-handlers)) deben actualizarse para controlar los recursos de tipo <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (el tipo de recurso dado a los controladores de autorización por enrutamiento de extremo).

MVC sigue usando `AuthorizationFilterContext` los recursos, por lo que si la aplicación usa filtros de autorización MVC junto con la autorización de enrutamiento de punto de conexión, puede que sea necesario controlar ambos tipos de recursos.

### SignalR

La asignación de SignalR hubs ahora tiene lugar dentro de `UseEndpoints` .

Asigne cada concentrador con `MapHub` . Como en versiones anteriores, cada concentrador aparece explícitamente en la lista.

En el ejemplo siguiente, se agrega compatibilidad con el `ChatHub` SignalR concentrador:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Existe una nueva opción para controlar los límites de tamaño de los mensajes de los clientes. Por ejemplo, en `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

En ASP.NET Core 2,2, puede establecer el `TransportMaxBufferSize` y el que controlarían de forma eficaz el tamaño máximo de los mensajes. En ASP.NET Core 3,0, esa opción ahora solo controla el tamaño máximo antes de que se observe la presión.

### <a name="mvc-controllers"></a>Controladores MVC

La asignación de controladores ahora tiene lugar dentro de `UseEndpoints` .

Agregue `MapControllers` si la aplicación usa el enrutamiento de atributos. Dado que el enrutamiento incluye compatibilidad con muchos marcos en ASP.NET Core 3,0 o posterior, la adición de controladores de enrutamiento de atributos es participación.

Reemplace lo siguiente:

* `MapRoute` con `MapControllerRoute`
* `MapAreaRoute` con `MapAreaControllerRoute`

Puesto que el enrutamiento ahora incluye compatibilidad con algo más que MVC, la terminología ha cambiado para que estos métodos indiquen claramente lo que hacen. Las rutas convencionales como `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` se aplican en el orden en que se agregan. Coloque primero rutas más específicas (por ejemplo, las rutas de un área).

En el ejemplo siguiente:

* `MapControllers` agrega compatibilidad con los controladores de enrutamiento de atributos.
* `MapAreaControllerRoute` agrega una ruta convencional para los controladores de un área.
* `MapControllerRoute` agrega una ruta convencional para los controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Eliminación de sufijo asincrónico de los nombres de acción del controlador

En ASP.NET Core 3,0, ASP.NET Core MVC quita el `Async` sufijo de los nombres de acción del controlador. El enrutamiento y la generación de vínculos se ven afectados por este nuevo valor predeterminado. Por ejemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes de ASP.NET Core 3,0:

* Se puede tener acceso a la acción anterior en la ruta *Products/ListAsync* .
* Generación de vínculos necesaria especificando el `Async` sufijo. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

En ASP.NET Core 3,0:

* Se puede tener acceso a la acción anterior en la ruta *Products/List* .
* La generación de vínculos no requiere especificar el `Async` sufijo. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Este cambio no afecta a los nombres especificados mediante el [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) atributo. El comportamiento predeterminado se puede deshabilitar con el código siguiente en `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Cambios en la generación de vínculos

Como se explica en la documentación sobre [las diferencias de las versiones anteriores de enrutamiento](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), hay algunas diferencias en la generación de vínculos ( `Url.Link` por ejemplo, mediante y API similares). Entre ellas se incluyen las siguientes:

* De forma predeterminada, al usar el enrutamiento de punto de conexión, no se conservan las mayúsculas y minúsculas de los parámetros de ruta en los URI generados. Este comportamiento se puede controlar con la `IOutboundParameterTransformer` interfaz.
* La generación de un URI para una ruta no válida (controlador/acción o página que no existe) generará una cadena vacía en enrutamiento de punto de conexión en lugar de generar un URI no válido.
* Los valores de ambiente (parámetros de ruta del contexto actual) no se usan automáticamente en la generación de vínculos con el enrutamiento de puntos de conexión. Anteriormente, al generar un vínculo a otra acción (o página), los valores de ruta no especificados se deducen de los valores de ambiente de las rutas *actuales* . Al usar el enrutamiento de punto de conexión, todos los parámetros de ruta deben especificarse explícitamente durante la generación de vínculos.

### <a name="no-locrazor-pages"></a>Razor Pages

RazorAhora, las páginas de asignación tienen lugar dentro de `UseEndpoints` .

Agregue `MapRazorPages` si la aplicación usa Razor páginas. Puesto que el enrutamiento del punto de conexión incluye compatibilidad con muchos marcos, agregar Razor páginas ahora es opcional.

En el `Startup.Configure` método siguiente, `MapRazorPages` agrega compatibilidad con Razor las páginas:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Uso de MVC sin enrutamiento de punto de conexión

El uso de MVC a través `UseMvc` `UseMvcWithDefaultRoute` de o en ASP.net Core 3,0 requiere una participación explícita dentro de `Startup.ConfigureServices` . Esto es necesario porque MVC debe saber si puede confiar en la autorización y el middleware CORS durante la inicialización. Se proporciona un analizador que advierte si la aplicación intenta usar una configuración no admitida.

Si la aplicación requiere compatibilidad heredada `IRouter` , deshabilite `EnableEndpointRouting` el uso de cualquiera de los métodos siguientes en `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Comprobaciones de estado

Las comprobaciones de estado se pueden usar como un *enrutador* con enrutamiento de punto de conexión.

Agregue `MapHealthChecks` para usar comprobaciones de estado con enrutamiento de punto de conexión. El `MapHealthChecks` método acepta argumentos similares a `UseHealthChecks` . La ventaja de usar `MapHealthChecks` over `UseHealthChecks` es la capacidad de aplicar la autorización y tener un control más preciso sobre la Directiva de coincidencia.

En el ejemplo siguiente, `MapHealthChecks` se llama a para un extremo de comprobación de estado en `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder reemplaza a WebHostBuilder

Las plantillas ASP.NET Core 3,0 usan el [host genérico](xref:fundamentals/host/generic-host). Las versiones anteriores usaban el [host web](xref:fundamentals/host/web-host). En el código siguiente se muestra la clase generada de la plantilla ASP.NET Core 3,0 `Program` :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

En el código siguiente se muestra la clase generada por la plantilla ASP.NET Core 2,2 `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> permanece en 3,0 y es el tipo del que se ha `webBuilder` detectado en el ejemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> quedará en desuso en una versión futura y se reemplazará por `HostBuilder` .

El cambio más significativo de `WebHostBuilder` a `HostBuilder` es en la [inserción de dependencias (di)](xref:fundamentals/dependency-injection). Cuando `HostBuilder` se usa, solo se puede insertar lo siguiente en el `Startup` constructor de:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Las `HostBuilder` restricciones de di:

* Habilite el contenedor de DI para que se compile solo una vez.
* Evita los problemas de duración de los objetos resultantes como resolver varias instancias de singleton.

Para obtener más información, consulte [evitar la inserción de servicios de inicio en ASP.net Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization se ha cambiado a otro ensamblado

Los métodos ASP.NET Core 2,2 y Lower `AddAuthorization` en *Microsoft.AspNetCore.Authorization.dll*:

* Se ha cambiado el nombre `AddAuthorizationCore` .
* Se han migrado a *Microsoft.AspNetCore.Authorization.Policy.dll*.

Las aplicaciones que usan *Microsoft.AspNetCore.Authorization.dll* y *Microsoft.AspNetCore.Authorization.Policy.dll* no se ven afectadas.

Las aplicaciones que no usan *Microsoft.AspNetCore.Authorization.Policy.dll* deben realizar una de las siguientes acciones:

* Agregue una referencia a *Microsoft.AspNetCore.Authorization.Policy.dll*. Este enfoque funciona en la mayoría de las aplicaciones y es todo lo que se necesita.
* Cambiar a con `AddAuthorizationCore`

Para obtener más información, vea [sobrecarga de cambios en `AddAuthorization(o =>` ) en un ensamblado diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="no-locidentity-ui"></a>IU de Identity

Identity Actualizaciones de la interfaz de usuario para ASP.NET Core 3,0:

* Agregue una referencia de paquete a [Microsoft. AspNetCore. Identity . Interfaz de usuario](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Las aplicaciones que no usan Razor páginas deben llamar a `MapRazorPages` . Vea [ Razor las páginas](#razor-pages) de este documento.
* Bootstrap 4 es el marco de interfaz de usuario predeterminado. Establezca una `IdentityUIFrameworkVersion` propiedad de proyecto para cambiar el valor predeterminado. Para obtener más información, consulte [este anuncio de github](https://github.com/aspnet/Announcements/issues/380).

## SignalR

El SignalR cliente de JavaScript ha cambiado de `@aspnet/signalr` a `@microsoft/signalr` . Para reaccionar a este cambio, cambie las referencias en *package.jsen* los archivos, las `require` instrucciones y las instrucciones de ECMAScript `import` .

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Jses el protocolo predeterminado

`System.Text.Json` es ahora el protocolo de concentrador predeterminado utilizado por el cliente y el servidor.

En `Startup.ConfigureServices` , llame `AddJsonProtocol` a para establecer las opciones del serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Cambiar a Newtonsoft.Jsactivado

Si está utilizando [las características de Newtonsoft.Jsen que no se admiten en System.Text.Jsen](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), puede volver a `Newtonsoft.Json` . Consulte [usar Newtonsoft.Jsen un SignalR proyecto ASP.net Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) anteriormente en este artículo.

## <a name="redis-distributed-caches"></a>Memorias caché distribuidas en Redis

El paquete [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) no está disponible para las aplicaciones ASP.net Core 3,0 o posteriores. Reemplace la referencia de paquete con [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Para obtener más información, vea <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Participar en la compilación en tiempo de ejecución

Antes de ASP.NET Core 3,0, la compilación de vistas en tiempo de ejecución era una característica implícita del marco. La compilación en tiempo de ejecución complementa la compilación en tiempo de compilación de las vistas. Permite al marco de trabajo compilar Razor vistas y páginas (archivos *. cshtml* ) cuando se modifican los archivos, sin tener que volver a generar toda la aplicación. Esta característica admite el escenario de realizar una edición rápida en el IDE y actualizar el explorador para ver los cambios.

En ASP.NET Core 3,0, la compilación en tiempo de ejecución es un escenario de participación. La compilación en tiempo de compilación es el único mecanismo para la compilación de vistas que está habilitada de forma predeterminada. El Runtime se basa en Visual Studio o [dotnet-Watch](xref:tutorials/dotnet-watch) en Visual Studio Code para recompilar el proyecto cuando detecta cambios en los archivos *. cshtml* . En Visual Studio, los cambios en los archivos *. CS*, *. cshtml* o *. Razor* del proyecto que se ejecuta (<kbd>Ctrl + F5</kbd>), pero no se depuran (<kbd>F5</kbd>), desencadenan la recompilación del proyecto.

Para habilitar la compilación en tiempo de ejecución en el proyecto ASP.NET Core 3,0:

1. Instale [Microsoft. AspNetCore. Mvc. Razor . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) Paquete NuGet de RuntimeCompilation.
1. Actualización `Startup.ConfigureServices` para llamar a `AddRazorRuntimeCompilation` :

    Para ASP.NET Core MVC, use el código siguiente:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    En el caso de Razor las páginas de ASP.net Core, utilice el siguiente código:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
En el ejemplo https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation de se muestra un ejemplo de cómo habilitar la compilación en tiempo de ejecución condicionalmente en entornos de desarrollo.

Para obtener más información sobre la Razor compilación de archivos, vea <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Migración de bibliotecas a través de la compatibilidad con múltiples versiones

Las bibliotecas suelen necesitar admitir varias versiones de ASP.NET Core. La mayoría de las bibliotecas compiladas con versiones anteriores de ASP.NET Core deberían seguir funcionando sin problemas. Las condiciones siguientes requieren la compilación cruzada de la aplicación:

* La biblioteca se basa en una característica que tiene un [cambio de interrupción](#breaking-api-changes)binario.
* La biblioteca desea aprovechar las nuevas características de ASP.NET Core 3,0. 

Por ejemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para habilitar ASP.net Core API específicas de 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Para obtener más información sobre el uso de ASP.NET Core API en una biblioteca de clases, vea <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Cambios varios

El sistema de validación de .NET Core 3.0 y versiones posteriores trata las propiedades enlazadas o los parámetros que no aceptan valores NULL como si tuvieran un atributo `[Required]`. Para obtener más información, vea el [atributo [required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publicar

Elimine las carpetas *bin* y *obj* en el directorio del proyecto.

## <a name="testserver"></a>TestServer

En el caso de las aplicaciones que usan <xref:Microsoft.AspNetCore.TestHost.TestServer> directamente con el [host genérico](xref:fundamentals/host/web-host), cree `TestServer` en un <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> en <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Interrupción de los cambios de API

Revisar cambios importantes:

* [Lista completa de cambios importantes en la versión ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Interrupción de los cambios de API en antifalsificación, CORS, diagnósticos, MVC y enrutamiento](https://github.com/aspnet/Announcements/issues/387). Esta lista incluye cambios importantes para los modificadores de compatibilidad.
* Para obtener un resumen de los cambios importantes de 2,2 a 3,0 en .NET Core, ASP.NET Core y Entity Framework Core, vea [cambios importantes para la migración de la versión 2,2 a la 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Enrutamiento de puntos de conexión con el parámetro catch-all

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 en Azure App Service

La implementación de .NET Core en Azure App Service ha finalizado. .NET Core 3,0 está disponible en todos los centros de recursos de Azure App Service.
